## 死锁

@(我的第一个笔记本)[分布式, 死锁, Markdown]
 
- **死锁定义**
- **代码分析** 
- **对上述程序产生死锁的解释** 

-------------------

[TOC]

-----------------------
#### 死锁定义

死锁就是两个或者多个进程，互相请求对方占有的资源。
`产生死锁的4个必要条件` ：

##### 互斥条件：
- 一个资源每次只能被一个进程使用

##### 请求与保持条件：
 - 一个进程因请求资源而阻塞时，对已获得的资源保持不放
#####  不剥夺条件:
- 进程已获得的资源，在末使用完之前，不能强行剥夺

##### 循环等待条件:
- 若干进程之间形成一种头尾相接的循环等待资源关系

--------------------------
#### 代码分析：
##### 关键字 synchronized:
- 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。

- 当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。

![Alt text](http://i1.piimg.com/4851/2c41474d582332c3.png)

##### 实验流程：
- 把上面的代码抄到 Deadlock.java里面,保存

![Alt text](http://i1.piimg.com/4851/32d11f23c53fa3ea.png)

- 在命令行运行 `javac Deadlock.java`

- Windows系统（把下面这段到记事本里，然后保存为.bat，然将批处理文件放在java程序（Deadlock.class）目录下，双击运行，观察结果

![Alt text](http://i1.piimg.com/4851/12f5abf75c9aadae.png)

- 上一步的4就是让这个程序跑一千遍，通常情况下，跑个几十遍就会停的像这样：跑到第188次就停了，多少次停是随机的，调节程序中count值，使其发生死锁。

![Alt text](http://i1.piimg.com/4851/6b90773aa6e04f1b.png)

--------------------------
#### 上述程序产生死锁的解释
*  死锁截图，停在了执行第188次的时候。因为此时a.methodA(b)和b.methodB(a)同时被调用。而由于使用了关键字synchronized，同一时刻最多只有一个线程能够执行。互相调用，导致死锁。满足产生死锁的四个必要条件。
